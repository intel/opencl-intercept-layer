#
# Copyright (c) 2018-2024 Intel Corporation
#
# SPDX-License-Identifier: MIT
#

import sys
import os
import re

# File Header:
def GetHeader():
    return """# How to Use the Intercept Layer for OpenCL Applications

This file is automatically generated using the script `generate_controls_doc.py`.
Please do not edit it manually!

By default, the Intercept Layer for OpenCL Applications will not modify any OpenCL
calls.  You may notice some status messages being printed to stderr, but otherwise
your application should run exactly as it does without the Intercept Layer for
OpenCL Applications.

## Controls

The Intercept Layer for OpenCL Applications is controlled using the Windows
registry, Linux configuration files, or environment variables on all OSes.

### Windows Registry

On Windows, the Intercept Layer for OpenCL Applications reads its registry keys
from:

    HKEY_CURRENT_USER\SOFTWARE\INTEL\IGFX\CLIntercept

This is the recommended registry location as it has several advantages over
HKEY_LOCAL_MACHINE: modifying the registry keys does not require Administrator
access, registry keys do not need to be set in multiple places, and each user
can set their own registry keys without affecting other users.

For backwards compatibility, the Intercept Layer for OpenCL applications
will still read registry keys from:

    // For 32-bit systems, or 64-bit applications on a 64-bit system:
    HKEY_LOCAL_MACHINE\SOFTWARE\INTEL\IGFX\CLIntercept

    // For 32-bit applications on a 64-bit system:
    HKEY_LOCAL_MACHINE\SOFTWARE\WoW6432Node\INTEL\IGFX\CLIntercept

If a registry is set in both HKCU and HKLM, the setting in HKCU will "win".

### Linux, Android, and OSX Configuration Files

On Linux, the Intercept Layer for OpenCL Applications will read control values
from a config file named clintercept.conf.  Controls in a config file may be
set by putting the control on its own line, followed by an equals sign,
followed by the value to set the control to.  Lines that begin with a
semi-colon (";"), a hash mark ("#"), or a C++-style comment ("//") are
ignored.  For example, to enable CallLogging, put a line in your 
clintercept.conf that looks like:

    // Enable CallLogging:
    CallLogging=1

The Intercept Layer for OpenCL Applications will search for config files in
the following directories, in order:

* The current user's HOME directory (`~`).
* The `sdcard` directory (for Android only).
* The system directory `/etc/OpenCL`.

### Environment Variables

The Intercept Layer for OpenCL may be controlled using environment variables.
The name of the environment variable control is "CLI_" and the control name, to
distinguish controls from other environment variables, and to make it easy to
list all of the environment variable controls.  So, to enable CallLogging, you
could type:

    export CLI_CallLogging=1

To disable CallLogging, you could type:

    unset CLI_CallLogging

To list all environment variable controls, you could type:

    env | grep CLI_

### Case Sensitivity

Controls should generally be considered case sensitive.  Some methods of
setting controls on some operating systems may treat controls as case
insensitive, but it is unsafe to rely on case insensitive behavior.

### Control Verification

To verify that a control has been set correctly and is taking effect,
please check the Intercept Layer for OpenCL Applications log file, which
will record any controls that are set to non-default values.

### Setup and Loading Controls

##### `OpenCLFileName` (string)

Used to control the DLL or Shared Library that the Intercept Layer for OpenCL Applications loads to make real OpenCL calls.
This can be a relative file name or a full absolute file name, but an absolute file name is recommended.
If present, only this file name is loaded.
If omitted, the Intercept Layer for OpenCL Applications tries to load the real OpenCL from file names in this order:

For Windows:

- `real_OpenCL.dll` (anywhere in the system path)
- `%WINDIR%\SysWOW64\OpenCL.dll` (32-bit DLLs only)
- `%WINDIR%\System32\OpenCL.dll`

For Linux:

- `./real_libOpenCL.so`
- `/usr/lib/x86_64-linux-gnu/libOpenCL.so.1` (optional, for systems with a detected multi-arch specifier)
- `/usr/lib/x86_64-linux-gnu/libOpenCL.so`
- `/usr/lib/libOpenCL.so.1`
- `/usr/lib/libOpenCL.so`
- `/usr/local/lib/libOpenCL.so.1`
- `/usr/local/lib/libOpenCL.so`
- `/opt/intel/opencl/lib64/libOpenCL.so.1`
- `/opt/intel/opencl/lib64/libOpenCL.so`
- `/glob/development-tools/oneapi/inteloneapi/compiler/latest/linux/lib/libOpenCL.so.1`
- `/glob/development-tools/oneapi/inteloneapi/compiler/latest/linux/lib/libOpenCL.so`

For Android:

- `/system/vendor/lib/real_libOpenCL.so`
- `real_libOpenCL.so`

This control is not used for OSX.

This control used to be called `DllName`.
The old name may still be used for backwards compatibility, but switching to the new name is recommended.

##### `BreakOnLoad` (bool)

If set to a nonzero value, the Intercept Layer for OpenCL Applications will break into the debugger when it is loaded.

"""

# File Footer:
def GetFooter():
    return """
---

\* Other names and brands may be claimed as the property of others.

Copyright (c) 2018-2024, Intel(R) Corporation
"""

printHelp = False

if len(sys.argv) < 3:
    nameControlsDoc = '../docs/controls.md'
else:
    nameControlsDoc = sys.argv[2]

if len(sys.argv) < 2:
    nameControlsSrc = '../intercept/src/controls.h'
else:
    nameControlsSrc = sys.argv[1]

if ( len(sys.argv) == 2 ) and ( sys.argv[1] == '-h' or sys.argv[1] == '-?' ):
    printHelp = True

if printHelp:
    print('usage: generate_controls_doc.py {optional: nameControlsSrc, default: ../intercept/src/controls.h} {optional: nameControlsDoc, default: ../docs/controls.md}')
elif not os.path.exists(nameControlsSrc):
    print('error: controls source file ' + nameControlsSrc + ' does not exist!')
else:
    print('Generating from source: ' + nameControlsSrc)

    srcFile = open(nameControlsSrc, 'r')
    docFile = open(nameControlsDoc, 'w')

    docFile.write( GetHeader() )

    numberOfSeparators = 0
    numberOfControls = 0

    for line in srcFile:
        separator = re.search("^CLI_CONTROL_SEPARATOR\((.*)\)$", line)
        if separator:
            full = separator.group(1).strip()

            # Remove the last character of the string (":"):
            full = full[:-1];

            docFile.write('### ' + full + '\n\n')

            #print('Got separator: ' + full)

            numberOfSeparators = numberOfSeparators + 1
            continue

        control = re.search("^CLI_CONTROL\((.*)\)$", line)
        if control:
            full = control.group(1).strip()

            data = full.split(',', 3)
            type = data[0].strip()
            name = data[1].strip()
            default = data[2].strip()
            description = data[3].strip()

            # Remove std:: from the type:
            type = type.replace("std::", "")

            # Remove the first and last characters of the description:
            description = description[1:-1];
            # Replace escaped quotes with real quotes:
            description = description.replace("\\\"", "\"")
            # Replace underscores with escaped underscores:
            description = description.replace("_", "\\_")
            # Escape angle brackets:
            description = description.replace("<", "\<")
            description = description.replace(">", "\>")

            docFile.write('##### `' + name + '` (' + type + ')\n\n')
            docFile.write(description + '\n\n')

            #print('Got control: ' + name)
            #print('  description: ' + description)

            numberOfControls = numberOfControls + 1
            continue

        #print('Not sure what to do with: ' + line)

    docFile.write( GetFooter() )

    srcFile.close()
    docFile.close()

    print('Successfully generated file: ' + nameControlsDoc)
    print('Found ' + str(numberOfSeparators) + ' control separators.')
    print('Found ' + str(numberOfControls) + ' controls.')
