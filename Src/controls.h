/*
// Copyright (c) 2018 Intel Corporation
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
*/

#ifndef CLI_CONTROL
#error Must define CLI_CONTROL before including this file!
#endif

#ifndef CLI_CONTROL_SEPARATOR
#define CLI_CONTROL_SEPARATOR( _name )
#endif

CLI_CONTROL_SEPARATOR( Logging Controls: )
CLI_CONTROL( bool,          SuppressLogging,                        false, "If set to a nonzero value, suppresses all logging output from the Intercept Layer for OpenCL Applications.  This is particularly useful for tools that only want report data." )
CLI_CONTROL( bool,          AppendFiles,                            false, "By default, the Intercept Layer for OpenCL Applications log files will be created from scratch when the intercept DLL is loaded, and any Intercept Layer for OpenCL Applications report files will be created from scratch when the intercept DLL is unloaded. If AppendFiles is set to a nonzero value, the Intercept Layer for OpenCL Applications will append to an existing file instead of recreating it. This can be useful if an application loads and unloads the intercept DLL multiple times, or to simply preserve log or report data from run-to-run." )
CLI_CONTROL( bool,          LogToFile,                              false, "If set to a nonzero value, sends log information to the file \"clintercept_log.txt\" instead of to stderr.  The log file will be placed in the directory \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\"." )
CLI_CONTROL( bool,          LogToDebugger,                          false, "If set to a nonzero value, sends log information to the debugger instead of to stderr.  If both LogToFile and LogToDebugger are nonzero then log information will be sent both to a file and to the debugger." )
CLI_CONTROL( int,           LogIndent,                              0,     "Indents each log entry by this many spaces." )
CLI_CONTROL( bool,          BuildLogging,                           false, "If set to a nonzero value, logs the program build log after each call to clBuildProgram().  This will likely only function correctly for synchronous builds.  Note that the build log is logged regardless of whether the program built successfully, which allows compiler warnings to be logged for successful compiles." )
CLI_CONTROL( bool,          PreferredWorkGroupSizeMultipleLogging,  false, "If set to a nonzero value, logs the preferred work group size multiple for each kernel after each call to clCreateKernel().  On some devices this is the equivalent of the SIMD size for this kernel." )
CLI_CONTROL( bool,          CallLogging,                            false, "If set to a nonzero value, logs function entry and exit information for every OpenCL call.  This can be used to easily determine which OpenCL call is causing an application to crash or fail or if a crash occurs outside of an OpenCL call.  This setting is best used with LogToFile or LogToDebugger as it can generate a lot of log data." )
CLI_CONTROL( bool,          CallLoggingEnqueueCounter,              false, "If set to a nonzero value, logs the enqueue counter in addition to function entry and exit information for every OpenCL call.  This can be used to determine appropriate limits for DumpBuffersMinEnqueue, DumpBuffersMaxEnqueue, DumpImagesMinEnqueue, or DumpBuffersMaxEnqueue.  If CallLogging is disabled then this control will have no effect." )
CLI_CONTROL( bool,          CallLoggingThreadId,                    false, "If set to a nonzero value, logs the ID of the calling thread in addition to function entry and exit information for every OpenCL call.  This can be helpful when debugging multi-threading issues." )
CLI_CONTROL( bool,          CallLoggingThreadNumber,                false, "If set to a nonzero value, logs the symbolic number of the calling thread in addition to function entry and exit information for every OpenCL call.  This can be helpful when debugging multi-threading issues." )
CLI_CONTROL( bool,          CallLoggingElapsedTime,                 false, "If set to a nonzero value, logs the elapsed time in microseconds in addition to function entry and exit information for every OpenCL call, starting from the time the intercept DLL is loaded." )
CLI_CONTROL( bool,          ITTCallLogging,                         false, "If set to a nonzero value, logs function entry and exit information for every OpenCL call using the ITT APIs.  This feature will only function if the Intercept Layer for OpenCL Applications is built with ITT support." )
CLI_CONTROL( bool,          ChromeCallLogging,                      false, "If set to a nonzero value, logs function entry and exit information for every OpenCL call to a JSON file that may be used for Chrome Tracing." )
CLI_CONTROL( bool,          ErrorLogging,                           false, "If set to a nonzero value, logs all OpenCL errors and the function name that caused the error." )
CLI_CONTROL( bool,          ErrorAssert,                            false, "If set to a nonzero value, breaks into the debugger when an OpenCL error occurs." )
CLI_CONTROL( bool,          ContextCallbackLogging,                 false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will install a callback for every context and log any calls to the context callback.  The application's context callback, if any, will be invoked after the Intercept Layer for OpenCL Applications' context callback." )
CLI_CONTROL( cl_uint,       ContextHintLevel,                       0,     "If set to a nonzero value, the Intercept Layer for OpenCL Applications will attempt to create contexts with the CL_CONTEXT_SHOW_DIAGNOSTICS_INTEL property set to the specified value.  If this property is specified by the application, the Intercept Layer for OpenCL Applications will overwrite it with the specified value, otherwise the property and the specified value will be added to the list of context creation properties.  This functionality is only available for OpenCL implementations that support the cl_intel_driver_diagnostics extension.  If this functionality is not available in the underlying OpenCL implementation, the unmodified list of context properties will be used to create the context instead. More information about this feature, including valid values and their meaning, can be found in the cl_intel_driver_diagnostics extension specification." )
CLI_CONTROL( bool,          EventCallbackLogging,                   false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will install its own callback for every event callback and log the call to the event callback.  The application's event callback will be invoked after the Intercept Layer for OpenCL Applications' event callback." )
CLI_CONTROL( bool,          EventChecking,                          false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will check and log any events in an event wait list that are invalid or in an error state.  This can help to debug complex event dependency issues." )
CLI_CONTROL( bool,          LeakChecking,                           false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will check for leaks of various OpenCL objects, such as memory objects and events." )
CLI_CONTROL( bool,          IndexLongKernelNames,                   false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will create a mapping to each kernel name longer than 32 characters to a shortName that will replace the kernel name in the logging. In addition, the mapping will be displayed on the clintercept_report.txt for easy reference." )
CLI_CONTROL( bool,          CLInfoLogging,                          false, "If set to a nonzero value, logs information about the platforms and devices in the system on the first call to clGetPlatformIDs()." )
CLI_CONTROL( std::string,   LogDir,                                 "",    "If set, the Intercept Layer for OpenCL Applications will emit logs to this directory instead of the default log directory." )


CLI_CONTROL_SEPARATOR( Reporting Controls: )
CLI_CONTROL( bool,          ReportToStderr,                         false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will emit reports to stderr." )
CLI_CONTROL( bool,          ReportToFile,                           true,  "If set to a nonzero value, the Intercept Layer for OpenCL Applications will write results to the file \"clintercept_report.txt\"." )

CLI_CONTROL_SEPARATOR( Performance Timing Controls: )
CLI_CONTROL( bool,          HostPerformanceTiming,                  false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will track the minimum, maximum, and average host CPU time for each OpenCL entry point.  When the process exits, this information will be printed to the file \"clIntercept_report.txt\" in the directory \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\"." )
CLI_CONTROL( bool,          DevicePerformanceTiming,                false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will add event profiling to track the minimum, maximum, and average device time for each OpenCL command. This operation may be fairly intrusive and may have side effects; in particular it forces all command queues to be created with PROFILING_ENABLED and may increment the reference count for application events. When the process exits, this information will be printed to the file \"clIntercept_report.txt\" in the directory \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\"." )
CLI_CONTROL( bool,          DevicePerformanceTimeHashTracking,      false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will distinguish between OpenCL NDRange kernels from programs with different hashes for the purpose of device performance timing." )
CLI_CONTROL( bool,          DevicePerformanceTimeKernelInfoTracking,false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will distinguish between OpenCL NDRange kernels using information such as the kernel's Preferred Work Group Size Multiple (AKA SIMD size)." )
CLI_CONTROL( bool,          DevicePerformanceTimeGWOTracking,       false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will distinguish between OpenCL NDRange kernels with different global work offsets for the purpose of device performance timing." )
CLI_CONTROL( bool,          DevicePerformanceTimeGWSTracking,       false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will distinguish between OpenCL NDRange kernels with different global work sizes for the purpose of device performance timing." )
CLI_CONTROL( bool,          DevicePerformanceTimeLWSTracking,       false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will distinguish between OpenCL NDRange kernels with different local work sizes for the purpose of device performance timing." )
CLI_CONTROL( bool,          DevicePerformanceTimingSkipUnmap,       false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will skip device performance timing for unmap operations.  This is a workaround for a bug in some OpenCL implementations, where querying events created from unmap operations results in driver crashes." )
CLI_CONTROL( bool,          HostPerformanceTimeLogging,             false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will log the host elapsed time for each OpenCL entry point.  This can be useful to identify OpenCL entry points that execute significantly slower or faster than average on the host." )
CLI_CONTROL( bool,          DevicePerformanceTimeLogging,           false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will log the device execution time deltas for each OpenCL command.  This can be useful to identify specific OpenCL commands that execute significantly slower or faster than average on the device.  If DevicePerformanceTiming is disabled then this control will have no effect." )
CLI_CONTROL( bool,          DevicePerformanceTimelineLogging,       false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will log the device execution times for each OpenCL command.  This can be useful to visualize the execution timeline of OpenCL commands that execute on the device.  If DevicePerformanceTiming is disabled then this control will have no effect." )
CLI_CONTROL( std::string,   DevicePerfCounterCustom,                "",    "If set, the Intercept Layer for OpenCL Applications will collect MDAPI metrics for the Metric Set corresponding to this value for each OpenCL command.  Frequently used Metric Sets include: ComputeBasic, ComputeExtended, L3_1, Sampler. The output file has the potential to be very big depending on the work load. This operation may be fairly intrusive and may have side effects; in particular it forces all command queues to be created with PROFILING_ENABLED and may increment the reference count for application events. When the process exits, this information will be printed to the file \"clintercept_perfcounter_dump_<Set Name>.txt\" in the directory \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  This feature will only function if the Intercept Layer for OpenCL Applications is built with MDAPI support." )
CLI_CONTROL( std::string,   DevicePerfCounterFile,                  "",    "Full path to a custom MDAPI file.  This can be used to add custom Metric Sets." )
CLI_CONTROL( bool,          DevicePerfCounterTiming,                false, "If set to a nonzero value and DevicePerfCounterCustom is set, the Intercept Layer for OpenCL Applications will enable Intel GPU Performance Counters to track the minimum, maximum, and average performance counter deltas for each OpenCL command. This operation may be fairly intrusive and may have side effects; in particular it forces all command queues to be created with PROFILING_ENABLED and may increment the reference count for application events. When the process exits, this information will be printed to the file \"clIntercept_report.txt\" in the directory \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  This feature will only function if the Intercept Layer for OpenCL Applications is built with MDAPI support." )
CLI_CONTROL( bool,          ITTPerformanceTiming,                   false, "[Note: This control makes ITT calls, but they appear to do nothing!]  If set to a nonzero value, the Intercept Layer for OpenCL Applications will generate ITT-compatible performance timing data.  Similar to DevicePerformanceTiming, this operation may be fairly intrusive and may have side effects; in particular it forces all command queues to be created with PROFILING_ENABLED and may increment the reference count for application events.  ITTPerformanceTiming will also silently create OpenCL command queues that support advanced performance counters if this functionality is available.  This feature will only function if the Intercept Layer for OpenCL Applications is built with ITT support." )
CLI_CONTROL( bool,          ITTShowOnlyExecutingEvents,             false, "[Note: This control makes ITT calls, but they appear to do nothing!]  By default, when ITTPerformanceTiming is enabled, the Intercept Layer for OpenCL Applications will generate ITT-compatible information for all states of an OpenCL event: when the command was queued, when it was submitted, when it started executing, and when it finished executing.  If ITTShowOnlyExecutingEvents is set to a nonzero value, the Intercept Layer for OpenCL Applications will only generate ITT-compatible instrumentation when an event begins executing and when an event ends executing. Since no information will be displayed about when a command is queued or submitted, this can sometimes make it easier to identify times when the device is idle.  This feature will only function if the Intercept Layer for OpenCL Applications is built with ITT support." )
CLI_CONTROL( bool,          ChromePerformanceTiming,                false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will generate device performance timing information in a JSON file that may be used for Chrome Tracing." )

CLI_CONTROL_SEPARATOR( Controls for Dumping and Injecting Programs and Build Options: )
CLI_CONTROL( bool,          OmitProgramNumber,                      false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will omit the program number from dumped file names and hash tracking.  This can produce deterministic results even if programs are built in a non-deterministic order (say, by multiple threads)." )
CLI_CONTROL( bool,          SimpleDumpProgramSource,                false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump the last string(s) passed to clCreateProgramWithSource() to the file kernel.cl, and the last program options passed to clBuildProgram() to the file kernel.txt.  These files will be dumped to the application's working directory.  If an application fails to compile a program and exits the program immediately after detecting a compile failure SimpleDumpProgram may be all that is needed to identify the program and program options that are failing to compile." )
CLI_CONTROL( bool,          DumpProgramSourceScript,                false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump every string passed to clCreateProgramWithSource() to its own file.  The directory names and file names for the dumped files match the directory names and file names expected by a modified OpenCL conformance test script to capture kernels.  This setting overrides SimpleDumpProgramSource, and if it is set to a nonzero value then the value of SimpleDumpProgramSource is ignored." )
CLI_CONTROL( bool,          DumpProgramSource,                      false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump every string passed to clCreateProgramWithSource() to its own file.  The files will be dumped to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  The filename will have the form \"CLI_<Program Number>_<Unique Program Hash Code>_source.cl\".  Program options that are passed to clBuildProgram() or clCompileProgram() will be dumped to the same directory with the filename \"CLI_<Program Number>_<Unique Program Hash Code>_<Compile Count>_options.txt\".  This setting can be used for information purposes to see all kernels that are used by an application or to dump programs for program injection.  This setting overrides DumpProgramSourceScript and SimpleDumpProgramSource, and if it is set to a nozero value then the values of DumpProgramSourceScript and SimpleDumpProgramSource will be ignored." )
CLI_CONTROL( bool,          DumpInputProgramBinaries,               false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump every program binary that is passed to clCreateProgramWithBinary() to its own file.  The files will be dumped to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  The filename will have the form \"CLI_<Program Number>_<Unique Program Hash Code>_<Device Type>.bin\".  This is the input program binary provided by the application, and not a device binary queried from the OpenCL implementation.  In particular, note that it may be a SPIR 1.2 binary." )
CLI_CONTROL( bool,          DumpProgramBinaries,                    false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump every program binary that was successfully built with clBuildProgram() to its own file.  The files will be dumped to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  The filename will have the form \"CLI_<Program Number>_<Unique Program Hash Code>_<Compile Count>_<Device Type>.bin\".  Program options that are passed to clBuildProgram() or clCompileProgram() will be dumped to the same directory with the filename \"CLI_<Program Number>_<Unique Program Hash Code>_<Compile Count>_options.txt\".  This setting can be used to examine compiled program binaries or to dump program binaries for program binary injection.  Note that this option dumps the output binary, which is a device binary, after calling clBuildProgram()." )
CLI_CONTROL( bool,          DumpProgramSPIRV,                       false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump every program IL binary passed to clCreateProgramWithIL() to its own file.  The files will be dumped to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  The filename will have the form \"CLI_<Program Number>_<Unique Program Hash Code>_0000.spv\" - for now at least!.  Program options that are passed to clBuildProgram() or clCompileProgram() will be dumped to the same directory with the filename \"CLI_<Program Number>_<Unique Program Hash Code>_<Compile Count>_options.txt\".  This setting can be used for information purposes to see all kernels that are used by an application or to dump SPIRV programs for SPIRV injection." )
CLI_CONTROL( bool,          InjectProgramSource,                    false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will look to inject potentially modified kernel source to clCreateProgramWithSource() and/or potentially modified options to clBuildProgram()." )
CLI_CONTROL( bool,          InjectProgramBinaries,                  false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will look to inject potentially modified kernel binaries via clCreateProgramWithBinary() in place of program text for each call to clCreateProgramWithSource(). This is typically done to reduce program compilation time or to use known good program binaries." )
CLI_CONTROL( bool,          RejectProgramBinaries,                  false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will reject kernel binaries passed via clCreateProgramWithBinary() and return CL_INVALID_BINARY.  This can be used to force an application to re-compile program binaries from source." )
CLI_CONTROL( bool,          InjectProgramSPIRV,                     false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will look to inject potentially modified kernel SPIR-V binaries via clCreateProgramWithIL() in place of program text for each call to clCreateProgramWithSource()." )
CLI_CONTROL( bool,          PrependProgramSource,                   false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will look to prepend kernel code from a file to the application provided kernel source passed to clCreateProgramWithSource().  The Intercept Layer for OpenCL Applications will look for kernel source to prepend in the directory \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  The files that are searched for are (in order) \"CLI_<Program Number>_<Unique Program Hash Code>_prepend.cl\", \"CLI_<Unique Program Hash Code>_prepend.cl\", and \"CLI_prepend.cl\"." )
CLI_CONTROL( std::string,   AppendBuildOptions,                     "",    "If set, the Intercept Layer for OpenCL Applications will add these build options to the end of any application provided or injected build options for each call to clBuildProgram()." )
CLI_CONTROL( bool,          DumpProgramBuildLogs,                   false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump build logs for every device a program is built for to a separate file.  The files will be dumped to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  The filename will have the form \"CLI_<Program Number>_<Unique Program Hash Code>_<Compile Count>_<Device Type>_build_log.txt\"." )
CLI_CONTROL( bool,          DumpKernelISABinaries,                  false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump kernel ISA binaries for every kernel, if supported.  An ISA binaries can decoded into ISA text with a disassembler.  The files will be dumped to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  The filename will have the form \"CLI_<Program Number>_<Unique Program Hash Code>_<Compile Count>_<Device Type>_<Kernel Name>.isabin\"." )

CLI_CONTROL_SEPARATOR( Controls for Automatically Creating SPIR-V Modules: )
CLI_CONTROL( bool,          AutoCreateSPIRV,                        false,       "If set to a nonzero value, the Intercept Layer for OpenCL Applications will automatically create SPIR-V modules by invoking CLANG each time a program is built.  The files will be dumped to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\".  The filename will have the form \"CLI_<Program Number>_<Unique Program Hash Code>_<Compile Count>.spv\".  Because invoking CLANG requires a file containing the OpenCL C source, setting this option implicitly sets DumpProgramSource as well.  Additionally, this feature is not available for injected program source." )
CLI_CONTROL( std::string,   SPIRVClang,                             "clang",     "The clang executable used to compile an OpenCL C program to a SPIR-V module.  This can be an executable in the system path, a relative path, or a full absolute path." )
CLI_CONTROL( std::string,   SPIRVCLHeader,                          "opencl.h",  "The OpenCL header file used to compile an OpenCL C program to a SPIR-V module.  This must be a relative path or a full absolute path." )
CLI_CONTROL( std::string,   SPIRVDis,                               "spirv-dis", "The spirv-dis executable used to optionally disassemble the compiled SPIR-V module to a SPIR-V text representation.  This can be an executable in the system path, a relative path, or a full absolute path." )
CLI_CONTROL( std::string,   DefaultOptions,                         "-cc1 -x cl -cl-std=CL1.2 -D__OPENCL_C_VERSION__=120 -D__OPENCL_VERSION__=120 -emit-spirv -triple=spir", "This is the list of options that is implicitly passed to CLANG to build a non-OpenCL 2.0 SPIR-V module.  Any application-provided build options will be appended to these build options." )
CLI_CONTROL( std::string,   OpenCL2Options,                         "-cc1 -x cl -cl-std=CL2.0 -D__OPENCL_C_VERSION__=200 -D__OPENCL_VERSION__=200 -emit-spirv -triple=spir", "This is the list of options that is implicitly passed to CLANG to build an OpenCL 2.0 SPIR-V module.  Any application-provided build options will be appended to these build options." )

CLI_CONTROL_SEPARATOR( Controls for Dumping Buffers and Images: )
CLI_CONTROL( bool,          DumpArgumentsOnSet,                     false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump the argument value on calls to clSetKernelArg(). Arguments are dumped as raw binary data to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\\SetKernelArg\".  The filenames will have the form \"SetKernelArg_<Enqueue Number>_Kernel_<Kernel Name>_Arg_<Argument Number>.bin\"." )
CLI_CONTROL( bool,          DumpBuffersAfterCreate,                 false, "If set, the Intercept Layer for OpenCL Applications will dump buffers to a file after creation.  This control still honors the enqueue counter limits, even though no enqueues are involved during buffer creation.  Currently only works for cl_mem buffers created from host pointers." )
CLI_CONTROL( bool,          DumpBuffersAfterMap,                    false, "If set, the Intercept Layer for OpenCL Applications will dump the contents of a buffer to a file after the buffer is mapped.  Only valid if the buffer is NOT mapped with CL_MAP_WRITE_INVALIDATE_REGION.  If the buffer was mapped non-blocking, this may insert a clFinish() into the command queue, which may have functional or performance implications." )
CLI_CONTROL( bool,          DumpBuffersBeforeUnmap,                 false, "If set, the Intercept Layer for OpenCL Applications will dump the contents of a buffer to a file immediately before the buffer is unmapped.  This is done by inserting a blocking clEnqueueMapBuffer() (and matching clEnqueueUnmapMemObject()) into the command queue, which may have functional or performance implications." )
CLI_CONTROL( bool,          DumpBuffersBeforeEnqueue,               false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump buffers before calls to clEnqueueNDRangeKernel().  Only buffers that are kernel arguments for the kernel being enqueued are dumped.  Buffers are dumped as raw binary data to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\\memDumpPreEnqueue\".  The filenames will have the form \"Enqueue_<Enqueue Number>_Kernel_<Kernel Name>_Arg_<Argument Number>_Buffer_<Unique Memory Object Number>.bin\"." )
CLI_CONTROL( bool,          DumpBuffersAfterEnqueue,                false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump buffers after calls to clEnqueueNDRangeKernel().  Only buffers that are kernel arguments for the kernel being enqueued are dumped.  Buffers are dumped as raw binary data to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\\memDumpPostEnqueue\".  The filenames will have the form \"Enqueue_<Enqueue Number>_Kernel_<Kernel Name>_Arg_<Argument Number>_Buffer_<Unique Memory Object Number>.bin\".  Note that this is the same naming convention as with DumpBuffersBeforeEnqueue, so the changes resulting from an enqueue can be determined by diff'ing the preEnqueue folder with the postEnqueue folder." )
CLI_CONTROL( std::string,   DumpBuffersForKernel,                   "",    "If set, the Intercept Layer for OpenCL Applications will only dump buffers when the specified kernel is enqueued.  This control is ignored unless DumpBuffersBeforeEnqueue or DumpBuffersAfterEnqueue are enabled." )
CLI_CONTROL( bool,          DumpImagesBeforeEnqueue,                false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump images before calls to clEnqueueNDRangeKernel().  Only images that are kernel arguments for the kernel being enqueued are dumped.  Images are dumped as raw binary data to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\\memDumpPreEnqueue\".  The filenames will have the form \"Enqueue_<Enqueue Number>_Kernel_<Kernel Name>_Arg_<Argument Number>_Image_<Unique Memory Object Number>_<Width>x<Height>x<Depth>_<Element Size>bpp.raw\"." )
CLI_CONTROL( bool,          DumpImagesAfterEnqueue,                 false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will dump images after calls to clEnqueueNDRangeKernel().  Only images that are kernel arguments for the kernel being enqueued are dumped.  Images are dumped as raw binary data to \"%SYSTEMDRIVE%\\Intel\\CLIntercept_Dump\\<Process Name>\\memDumpPostEnqueue\".  The filenames will have the form \"Enqueue_<Enqueue Number>_Kernel_<Kernel Name>_Arg_<Argument Number>_Image_<Unique Memory Object Number>_<Width>x<Height>x<Depth>_<Element Size>bpp.raw\".  Note that this is the same naming convention as with DumpImagesBeforeEnqueue, so the changes resulting from an enqueue can be determined by diff'ing the preEnqueue folder with the postEnqueue folder." )
CLI_CONTROL( std::string,   DumpImagesForKernel,                    "",    "If set, the Intercept Layer for OpenCL Applications will only dump image when the specified kernel is enqueued.  This control is ignored unless DumpImagesBeforeEnqueue or DumpImagesAfterEnqueue are enabled." )
CLI_CONTROL( cl_uint,       DumpBuffersMinEnqueue,                  0,     "The Intercept Layer for OpenCL Applications will only dump buffers when the enqueue counter is greater than this value, inclusive." )
CLI_CONTROL( cl_uint,       DumpBuffersMaxEnqueue,                  UINT_MAX, "The Intercept Layer for OpenCL Applications will only dump buffers when the enqueue counter is less than this value, inclusive." )
CLI_CONTROL( cl_uint,       DumpImagesMinEnqueue,                   0,     "The Intercept Layer for OpenCL Applications will only dump images when the enqueue counter is greater than this value, inclusive." )
CLI_CONTROL( cl_uint,       DumpImagesMaxEnqueue,                   UINT_MAX, "The Intercept Layer for OpenCL Applications will only dump images when the enqueue counter is less than this value, inclusive." )

CLI_CONTROL_SEPARATOR( AubCapture Controls: )
CLI_CONTROL( bool,          AubCapture,                             false, "This is the master control for aub capture.  The Intercept Layer for OpenCL Applications doesn't implement aub capture itself, but can be used to selectively enable and disable aub capture via kdc.exe." )
CLI_CONTROL( bool,          AubCaptureIndividualEnqueues,           false, "If set, the Intercept Layer for OpenCL Applications will invoke kdc.exe to start aub capture before a kernel enqueue, and will also invoke kdc.exe to stop aub capture immediately after the kernel enqueue.  Each .daf file will have the form \"AubCapture_Enqueue_<Enqueue Number>_kernel_<Kernel Name>.daf\".  Note that non-kernel enqueues such as calls to clEnqueueReadBuffer() and clEnqueueWriteBuffer() will NOT be aub captured when this control is set.  The AubCaptureMinEnqueue and AubCaptureMaxEnqueue controls are still honored when AubCaptureIndividualEnqueues is set." )
CLI_CONTROL( cl_uint,       AubCaptureMinEnqueue,                   0,     "The Intercept Layer for OpenCL Applications will only invoke kdc.exe to enable aub capture when the enqueue counter is greater than this value, inclusive." )
CLI_CONTROL( cl_uint,       AubCaptureMaxEnqueue,                   UINT_MAX, "The Intercept Layer for OpenCL Applications will invoke kdc.exe to stop aub capture when the encounter is greater than this value, meaning that only enqueues less than this value, inclusive, will be captured.  If the enqueue counter never reaches this value, the Intercept Layer for OpenCL Applications will stop aub capture when the DLL is unloaded." )
CLI_CONTROL( std::string,   AubCaptureKernelName,                   "",     "If set, the Intercept Layer for OpenCL Applications will only invoke kdc.exe to enable aub capture when the kernel name equals this name.")
CLI_CONTROL( std::string,   AubCaptureKernelGWS,                    "",     "If set, the Intercept Layer for OpenCL Applications will only invoke kdc.exe to enable aub capture when the NDRange global work size matches this string.  The string should have the form \"XxYxZ\".  The wildcard \"*\" matches all global work sizes.")
CLI_CONTROL( std::string,   AubCaptureKernelLWS,                    "",     "If set, the Intercept Layer for OpenCL Applications will only invoke kdc.exe to enable aub capture when the NDRange local work size matches this string.  The string should have the form \"XxYxZ\".  The wildcard \"*\" matches all local work sizes, and the string \"NULL\" matches a NULL local work size.")
CLI_CONTROL( bool,          AubCaptureUniqueKernels,                false,  "If set, the Intercept Layer for OpenCL Applications will only invoke kdc.exe to enable aub capture if the kernel signature (i.e. hash + kernelname + gws + lws) has not been seen already.  The behavior of this control is well-defined when AubCaptureIndividualEnqueues is not set, but it doesn't make much sense without AubCaptureIndividualEnqueues." )
CLI_CONTROL( cl_uint,       AubCaptureNumKernelEnqueuesSkip,        0,      "The Intercept Layer for OpenCL Applications will skip this many kernel enqueues before invoking kdc.exe to enable aub capture.  The behavior of this control is well-defined when AubCaptureIndividualEnqueues is not set, but it doesn't make much sense without AubCaptureIndividualEnqueues.")
CLI_CONTROL( cl_uint,       AubCaptureNumKernelEnqueuesCapture,     UINT_MAX, "The Intercept Layer for OpenCL Applications will only capture this many kernel enqueues.  The behavior of this control is well-defined when AubCaptureIndividualEnqueues is not set, but it doesn't make much sense without AubCaptureIndividualEnqueues.")
CLI_CONTROL( cl_uint,       AubCaptureStartWait,                    0,      "The Intercept Layer for OpenCL Applications will wait for this many milliseconds before invoking kdc.exe to begin aub capture.")
CLI_CONTROL( cl_uint,       AubCaptureEndWait,                      0,      "The Intercept Layer for OpenCL Applications will wait for this many milliseconds before invoking kdc.exe to end aub capture.")

CLI_CONTROL_SEPARATOR( Execution Controls: )
CLI_CONTROL( bool,          NoErrors,                               false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will cause all OpenCL APIs to return a successful error status." )
CLI_CONTROL( bool,          NullContextCallback,                    false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will force the context callback to be NULL.  With both context callback logging and NULL context callback set, the context callback will still be logged, but any application context callback will not be called." )
CLI_CONTROL( bool,          FinishAfterEnqueue,                     false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications inserts a call to clFinish() after every enqueue.  The command queue that the command was just enqueued to is passed to clFinish().  This can be used to debug possible timing or resource management issues and will likely impact performance." )
CLI_CONTROL( bool,          FlushAfterEnqueue,                      false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications inserts a call to clFlush() after every enqueue.  The command queue that the command was just enqueued to is passed to clFlush().  This can also be used to debug possible timing or resource management issues and is slightly less obtrusive than FinishAfterEnqueue but still will likely impact performance.  If both FinishAfterEnqueue and FlushAfterEnqueue are nonzero then the Intercept Layer for OpenCL Applications will only insert a call to clFinish() after every enqueue, because clFinish() implies clFlush()." )
CLI_CONTROL( bool,          FlushAfterEnqueueBarrier,               false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications inserts a call to clFlush() after every barrier enqueue.  The command queue that the command was just enqueued to is passed to clFlush().  This has been useful to debug out-of-order queue issues." )
CLI_CONTROL( bool,          InOrderQueue,                           false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will force all queues to be created in-order.  This can be used for performance analysis, but may lead to deadlocks in some cases." )
CLI_CONTROL( bool,          NullEnqueue,                            false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will silently ignore any enqueue.  This can be used for performance analysis, but will likely cause errors if the application relies on any sort of information from OpenCL events and should be used carefully." )
CLI_CONTROL( bool,          NullLocalWorkSize,                      false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will force the local work size argument to clEnqueueNDRangeKernel() to be NULL, which causes the OpenCL implementation to pick the local work size. Note that this control takes effect before NullLocalWorkSizeX / NullLocalWorkSizeY / NullLocalWorkSizeZ (see below), so enabling both controls will have the effect of forcing a specific local work size." )
CLI_CONTROL( size_t,        NullLocalWorkSizeX,                     0,     "If set to a nonzero value, the Intercept Layer for OpenCL Applications will set the local work size that will be used if an application passes NULL as the local work size to clEnqueueNDRangeKernel().  1D dispatches will only look at NullLocalWorkSizeX, 2D dispatches will only look at NullLocalWorkSizeX and NullLocalWorkSizeY, while 3D dispatches will look at NullLocalWorkSizeX, NullLocalWorkSizeY, and NullLocalWorkSizeZ.  If the specified values for NullLocalWorkSize do not evenly divide the global work size then the specified values of NullLocalWorkSize will not take effect." )
CLI_CONTROL( size_t,        NullLocalWorkSizeY,                     0,     "If set to a nonzero value, the Intercept Layer for OpenCL Applications will set the local work size that will be used if an application passes NULL as the local work size to clEnqueueNDRangeKernel().  1D dispatches will only look at NullLocalWorkSizeX, 2D dispatches will only look at NullLocalWorkSizeX and NullLocalWorkSizeY, while 3D dispatches will look at NullLocalWorkSizeX, NullLocalWorkSizeY, and NullLocalWorkSizeZ.  If the specified values for NullLocalWorkSize do not evenly divide the global work size then the specified values of NullLocalWorkSize will not take effect." )
CLI_CONTROL( size_t,        NullLocalWorkSizeZ,                     0,     "If set to a nonzero value, the Intercept Layer for OpenCL Applications will set the local work size that will be used if an application passes NULL as the local work size to clEnqueueNDRangeKernel().  1D dispatches will only look at NullLocalWorkSizeX, 2D dispatches will only look at NullLocalWorkSizeX and NullLocalWorkSizeY, while 3D dispatches will look at NullLocalWorkSizeX, NullLocalWorkSizeY, and NullLocalWorkSizeZ.  If the specified values for NullLocalWorkSize do not evenly divide the global work size then the specified values of NullLocalWorkSize will not take effect." )
CLI_CONTROL( bool,          InitializeBuffers,                      false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will initialize the contents of allocated buffers with zero.  Only valid for non-COPY_HOST_PTR and non-USE_HOST_PTR allocations." )

CLI_CONTROL_SEPARATOR( Platform and Device Query Overrides: )
CLI_CONTROL( std::string,   PlatformName,                           "",    "If set to a non-empty value, the clGetPlatformInfo() query for CL_PLATFORM_NAME will return this string instead of the true platform name." )
CLI_CONTROL( std::string,   PlatformVendor,                         "",    "If set to a non-empty value, the clGetPlatformInfo() query for CL_PLATFORM_VENDOR will return this string instead of the true platform vendor." )
CLI_CONTROL( std::string,   PlatformProfile,                        "",    "If set to a non-empty value, the clGetPlatformInfo() query for CL_PLATFORM_PROFILE will return this string instead of the true platform profile." )
CLI_CONTROL( std::string,   PlatformVersion,                        "",    "If set to a non-empty string, the clGetPlatformInfo() query for CL_PLATFORM_VERSION will return this string instead of the true platform version." )
CLI_CONTROL( cl_uint,       DeviceTypeFilter,                       CL_DEVICE_TYPE_ALL, "Hides all device types that are not in the filter.  Note: CL_DEVICE_TYPE_CPU = 2, CL_DEVICE_TYPE_GPU = 4, CL_DEVICE_TYPE_ACCELERATOR = 8, CL_DEVICE_TYPE_CUSTOM = 16." )
CLI_CONTROL( cl_uint,       DeviceType,                             0,     "If set to a non-zero value, the clGetDeviceInfo() query for CL_DEVICE_TYPE will return this value instead of the true device type.  In addition, calls to clGetDeviceIDs() for this device type will return all devices, not just devices of the requested type.  This can be used to enumerate all devices (even CPUs) as GPUs, or vice versa." )
CLI_CONTROL( std::string,   DeviceName,                             "",    "If set to a non-empty string, the clGetDeviceInfo() query for CL_DEVICE_NAME will return this value instead of the true device name." )
CLI_CONTROL( std::string,   DeviceVendor,                           "",    "If set to a non-empty string, the clGetDeviceInfo() query for CL_DEVICE_VENDOR will return this value instead of the true device vendor." )
CLI_CONTROL( std::string,   DeviceProfile,                          "",    "If set to a non-empty string, the clGetDeviceInfo() query for CL_DEVICE_PROFILE will return this value instead of the true device profile." )
CLI_CONTROL( std::string,   DeviceVersion,                          "",    "If set to a non-empty string, the clGetDeviceInfo() query for CL_DEVICE_VERSION will return this value instead of the true device version." )
CLI_CONTROL( std::string,   DeviceCVersion,                         "",    "If set to a non-empty string, the clGetDeviceInfo() query for CL_DEVICE_OPENCL_C_VERSION will return this value instead of the true device version." )
CLI_CONTROL( std::string,   DeviceExtensions,                       "",    "If set to a non-empty string, the clGetDeviceInfo() query for CL_DEVICE_EXTENSIONS will return this value instead of the true device extensions string." )
CLI_CONTROL( cl_uint,       DeviceVendorID,                         0,     "If set to a non-zero value, the clGetDeviceInfo() query for CL_DEVICE_VENDOR will return this value instead of the true device vendor ID." )
CLI_CONTROL( cl_uint,       DeviceMaxComputeUnits,                  0,     "If set to a non-zero value, the clGetDeviceInfo() query for CL_DEVICE_MAX_COMPUTE_UNITS will return this value instead of the true device max compute units." )
CLI_CONTROL( cl_uint,       DevicePreferredVectorWidthChar,         UINT_MAX, "If set to a non-negative value, the clGetDeviceInfo() query for CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR will return this value instead of the true device preferred vector width." )
CLI_CONTROL( cl_uint,       DevicePreferredVectorWidthShort,        UINT_MAX, "If set to a non-negative value, the clGetDeviceInfo() query for CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT will return this value instead of the true device preferred vector width." )
CLI_CONTROL( cl_uint,       DevicePreferredVectorWidthInt,          UINT_MAX, "If set to a non-negative value, the clGetDeviceInfo() query for CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT will return this value instead of the true device preferred vector width." )
CLI_CONTROL( cl_uint,       DevicePreferredVectorWidthLong,         UINT_MAX, "If set to a non-negative value, the clGetDeviceInfo() query for CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG will return this value instead of the true device preferred vector width." )
CLI_CONTROL( cl_uint,       DevicePreferredVectorWidthHalf,         UINT_MAX, "If set to a non-negative value, the clGetDeviceInfo() query for CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF will return this value instead of the true device preferred vector width." )
CLI_CONTROL( cl_uint,       DevicePreferredVectorWidthFloat,        UINT_MAX, "If set to a non-negative value, the clGetDeviceInfo() query for CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT will return this value instead of the true device preferred vector width." )
CLI_CONTROL( cl_uint,       DevicePreferredVectorWidthDouble,       UINT_MAX, "If set to a non-negative value, the clGetDeviceInfo() query for CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE will return this value instead of the true device preferred vector width." )

CLI_CONTROL_SEPARATOR( Precompiled Kernel and Builtin Kernel Override Controls: )
CLI_CONTROL( bool,          ForceByteBufferOverrides,               false, "If set to a nonzero value, each of the buffer functions that are overridden (via one or more of the keys below) will use a byte-wise operation to read/write/copy the buffer (default behavior is to try to copy multiple bytes at a time, if possible).  Note: Requires OpenCL 1.1 or the \"byte addressable store\" extension." )
CLI_CONTROL( bool,          OverrideReadBuffer,                     false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will use a kernel to implement clEnqueueReadBuffer() instead of the implementation's clEnqueueReadBuffer().  Note: Requires OpenCL 1.1 or the \"byte addressable store\" extension." )
CLI_CONTROL( bool,          OverrideWriteBuffer,                    false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will use a kernel to implement clEnqueueWriteBuffer() instead of the implementation's clEnqueueWriteBuffer().  Note: Requires OpenCL 1.1 or the \"byte addressable store\" extension." )
CLI_CONTROL( bool,          OverrideCopyBuffer,                     false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will use a kernel to implement clEnqueueCopyBuffer() instead of the implementation's clEnqueueCopyBuffer().  Note: Requires OpenCL 1.1 or the \"byte addressable store\" extension." )
CLI_CONTROL( bool,          OverrideReadImage,                      false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will use a kernel to implement clEnqueueReadImage() instead of the implementation's clEnqueueReadImage().  Only 2D images are currently supported." )
CLI_CONTROL( bool,          OverrideWriteImage,                     false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will use a kernel to implement clEnqueueWriteImage() instead of the implementation's clEnqueueWriteImage().  Only 2D images are currently supported." )
CLI_CONTROL( bool,          OverrideCopyImage,                      false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will use a kernel to implement clEnqueueCopyImage() instead of the implementation's clEnqueueCopyImage().  Only 2D images are currently supported." )
CLI_CONTROL( bool,          OverrideBuiltinKernels,                 false, "If set to a nonzero value, the Intercept Layer for OpenCL Applications will use its own version of the built-in OpenCL kernels that may be accessed via clCreateProgramWithBuiltInKernels(). At present, only the VME block_motion_estimate_intel kernel is implemented." )

CLI_CONTROL_SEPARATOR( SIMD Survey Controls: )
CLI_CONTROL( bool,          SIMDSurvey,                             false, "Executes a SIMD survey state machine.  The general idea of the SIMD survey state machine is to create and manage three additional kernels for each actual OpenCL kernel, one for each SIMD size.  Then, execute and time the three kernels, and choose the fastest for subsequent executions." )
CLI_CONTROL( cl_uint,       SIMDSurveyWarmupIterations,             4,     "This is the number of NDRanges that the SIMD survey state machine ignores before starting to time the SIMD survey." )
CLI_CONTROL( std::string,   SIMDSurveySIMD8Option,                  "-DSIMD_SURVEY=8 ", "This is the build option that is pre-pended to the application-specified build options to create the SIMD8 kernel." )
CLI_CONTROL( std::string,   SIMDSurveySIMD16Option,                 "-DSIMD_SURVEY=16", "This is the build option that is pre-pended to the application-specified build options to create the SIMD16 kernel." )
CLI_CONTROL( std::string,   SIMDSurveySIMD32Option,                 "-DSIMD_SURVEY=32", "This is the build option that is pre-pended to the application-specified build options to create the SIMD32 kernel." )
CLI_CONTROL( bool,          SIMDOracle,                             false, "[Note: Not currently implemented, but the idea behind the SIMD oracle is to save the best SIMD size from run-to-run, so the full SIMD survey does not need to be re-executed.]" )
